function [obj_evol] = flow(obj,s,x,p,defo)
% computes the evolution of the obj under the flow generated by x/p.

[nx,~]=size(x);
[ny,~]=size(obj);
h = 1 ./ defo.nb_euler_steps;

obj_evol= cell(1,defo.nb_euler_steps +1);
obj_evol{1} = obj;

defo.Css = ((repmat(obj(:,1),1,nx)-repmat(s',ny,1)).^2)/(defo.kernel_size_mom(1,1))^2;

for i = 1:defo.nb_euler_steps
    % Midpoint method 
    obj1 = euler_mat(x{i},p{i},obj_evol{i}(:,2),defo,h/2);
    obj2 = euler_mat((x{i}+x{i+1})/2,(p{i} + p{i+1})/2,obj1,defo,h);

    obj_evol{i+1} = [obj(:,1), obj2 - obj1 + obj_evol{i}(:,2)];
end
    
end

function [nobj] = euler_mat(x,p,obj,defo,h)
% This function implements an elementary Euler Step in cuda

[nx,~]=size(x);
[ny,~]=size(obj);

% S = zeros(ny,nx);
S = defo.Css + ((repmat(obj,1,nx)-repmat(x',ny,1)).^2)/(defo.kernel_size_mom(1,2))^2;
A = exp(-S);
% for l=1:d
%     S=S+(repmat(obj(:,l),1,nx)-repmat(x(:,l)',ny,1)).^2;
% end
% A = rho(S,0,defo.kernel_size_mom);
% 
 nobj = obj + h * A*p;

end